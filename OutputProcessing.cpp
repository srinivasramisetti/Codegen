#include "stdafx.h"
#include "codegen.h"
#include "Globals.h"
#include "ModelProcessing.h"
#include "OutputProcessing.h"
#include "Utils.h"

//****************************************************************************
// Name:  UpdateFSMFiles
//
// This generates the following information based on the information stored
// in the Diagram object (stored by the ProcessModelFile function) and places
// it in the appropriate FSM source and header files in areas marked by
// __BEG_AUTO_GEN_AREA and __END_AUTO_GEN_AREA:
//    - FSM configuration
//    - #defined list of states
//    - entry, activity, exit, and transition action function prototypes
//    - entry, activity, exit, and transition action function definitions
//
//****************************************************************************
void UpdateFSMFiles(void)
{
    // Update the FSM files
    UpdateConfigSourceFile();
    UpdatePublicHeaderFile();
    UpdatePrivateHeaderFile();
    UpdateFunctsSourceFile();
    if (GenerateDebugCode)
    {
        UpdateDebugSourceFile();
    }
}

//****************************************************************************
// Name:  UpdateConfigSourceFile
//
// This updates the ..._fsm_config.c file.  This returns a CString containing
// any transistion errors that were encountered (limited to 50 so it won't
// scroll of the screen).  If there were no transition errors, then the
// return string will be "".
//****************************************************************************
void UpdateConfigSourceFile(void)
{
    int zz, TempFileLines, State = LOOKING_FOR_BEG_AUTO_GEN_AREA;
    int jj, kk;
	char TempArray[50];
    CString TempCString, TempCString2, TempCString3;
    CString TempCString4, TempCString5;

    // Open the <FSM name>_fsm_config.h file, store it in a class array, and
    // find out how many lines are in the file.
    OutputFSMConfigFile.OpenFileForReading(FSMOutputFilesPath + StateMachineName + "_fsm_config.c");
    OutputFSMConfigFile.StoreEntireFile();
    TempFileLines = OutputFSMConfigFile.GetNumberFileLines();
    OutputFSMConfigFile.CloseFile();

    // Create a new file with the same name (destroy the original file)
    OutputFSMConfigFile.OpenNewFile(FSMOutputFilesPath + StateMachineName + "_fsm_config.c");
    // FOR1 All lines in the file
    for(zz = 0; zz < TempFileLines; zz++)
    { // Process the file
        switch(State)
        {
        case(LOOKING_FOR_BEG_AUTO_GEN_AREA):
            { // Store all lines from the array in the new file up until
                // the /*__BEG_AUTO_GEN_AREA*/ marker
                TempCString = OutputFSMConfigFile.GetEntireFileLine(zz);
                TempCString.Remove('\n');
				// IF1 The marker is reached
                if("/*__BEG_AUTO_GEN_AREA*/" == TempCString)
                { // THEN1 Change to the next state
                    State = ADDING_AUTO_GEN_DATA;
                }
				// Store the current file line
                OutputFSMConfigFile.PutString(OutputFSMConfigFile.GetEntireFileLine(zz));
                break;
            }
        case(ADDING_AUTO_GEN_DATA):
            {  // Add the autogenerated configuration data
				// Start with the time stamp
                OutputTimeStampAndInfo(OutputFSMConfigFile);

				// Add the workspace allocation
				OutputFSMConfigFile.PutString("/* Allocate workspace */\n");
				OutputFSMConfigFile.PutString("FSM_WORKSPACE_T ");
				OutputFSMConfigFile.PutString(StateMachineName);
				OutputFSMConfigFile.PutString("_fsm_workspace;\n\n");

                // Add the configuration data
				OutputFSMConfigFile.PutString("/* State machine configuration */\n\n");

                // Output the transition configuration structures for all states
                // FOR2 All states
                for(jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
                {
                    // Output the beginning of the trans config for the current state
                    TempCString = ConvertStateNumberToText(jj);
                    OutputTransBeg(TempCString);

                    // Output all of the transitions (in C file format)
                    // FOR3 All transitions
                    for(kk = 0; kk < Diagram.GetNumTrans(NON_SUPER_STATE, jj); kk++)
                    {
						// IF2 The current trans is ok (I don't really need this validity
						// check as long as CheckForTransitionErrors is called before
						// UpdateFSMFiles is called and UpdateFSMFiles is not called if any
						// transition errors are found during the CheckForTransitionErrors call)
                        if("OK" == Diagram.GetTransStatus(NON_SUPER_STATE, jj, kk))
                        { // THEN2 Output it normally
                            OutputTrans(ConvertStateNumberToText(Diagram.GetTransTargetState(NON_SUPER_STATE, jj, kk)),
                                _itoa(Diagram.GetTransCondMask(NON_SUPER_STATE, jj, kk), &TempArray[0], 16),
                                _itoa(Diagram.GetTransDontCareMask(NON_SUPER_STATE, jj, kk), &TempArray[0], 16),
                                Diagram.GetTransActionFunctionName(NON_SUPER_STATE, jj, kk));
                        }
                    } // END FOR3

                    // Output the end of the trans config structure
                    OutputTransEnd();
                } // END FOR2

                // Output the state configuration structures for all states
                // Start with the beginning of the state config structure
                OutputStateBeg(StateMachineName);

                // Output all of the states (in C file format)
                // FOR7 All states
                for(jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
                {
                    OutputState(ConvertStateNumberToText(jj));
                }
                // Output the end of the state config structure
                OutputStateEnd();
                // Output the state machine main configuration
                OutputMainStateMachineConfig();

                OutputFSMConfigFile.PutString("/*__END_AUTO_GEN_AREA*/");
                OutputFSMConfigFile.PutChar('\n');
                State = LOOKING_FOR_END_AUTO_GEN_AREA;
                break;
            }
        case(LOOKING_FOR_END_AUTO_GEN_AREA):
            {
                // Ignore all "old" lines up until the /*__END_AUTO_GEN_AREA*/ marker
                TempCString = OutputFSMConfigFile.GetEntireFileLine(zz);
                TempCString.Remove('\n');
				// IF9 The marker is reached
                if("/*__END_AUTO_GEN_AREA*/" == TempCString)
                { // THEN9 Change to the next state
                    State = FINISHING_UP;
                }
                break;
            }
        case(FINISHING_UP):
            {
                // Store the rest of the file after the /*__END_AUTO_GEN_AREA*/
                OutputFSMConfigFile.PutString(OutputFSMConfigFile.GetEntireFileLine(zz));
                break;
            }
        }
    }
}

//****************************************************************************
// Name:  OutputTimeStampAndInfo
//
// This outputs when this section was auto-generated and what files were used.
//****************************************************************************
void OutputTimeStampAndInfo(File FileToUpdate)
{
    // Set the environment variable to generate dummy date/time and file and file names.
    // (Useful for comparing results vs. a golden benchmark file.)
    if (getenv("CODEGEN_TEST") != NULL)
    {
        FileToUpdate.PutString("/* Generated at hh:mm on dd/mm/yyyy using the following files:\n");
        FileToUpdate.PutString("   ");
        FileToUpdate.PutString(CODEGEN_VERSION_STRING);
        FileToUpdate.PutString('\n');
        FileToUpdate.PutString("   Model file: (ModelFile)\n");
        FileToUpdate.PutString("   Config file: (ConfigFile) */\n\n");
    }
    else
    {
        char TempArray[50];
        FileToUpdate.PutString("/* Generated at ");
        FileToUpdate.PutString(_itoa(CurrentLocalTime.wHour, &TempArray[0], 10));
        FileToUpdate.PutString(":");
        FileToUpdate.PutString(_itoa(CurrentLocalTime.wMinute, &TempArray[0], 10));
        FileToUpdate.PutString(" on ");
        FileToUpdate.PutString(_itoa(CurrentLocalTime.wMonth, &TempArray[0], 10));
        FileToUpdate.PutString("/");
        FileToUpdate.PutString(_itoa(CurrentLocalTime.wDay, &TempArray[0], 10));
        FileToUpdate.PutString("/");
        FileToUpdate.PutString(_itoa(CurrentLocalTime.wYear, &TempArray[0], 10));
        FileToUpdate.PutString(" using the following files:\n");
        FileToUpdate.PutString("   ");
        FileToUpdate.PutString(CODEGEN_VERSION_STRING);
        FileToUpdate.PutString('\n');
        FileToUpdate.PutString("   Model file: " + ModelFile.GetFileName() + '\n');
        FileToUpdate.PutString("   Config file: " + ConfigFile.GetFileName() + " */\n\n");
    }
}

//****************************************************************************
// Name:  OutputTransBeg
//
// This outputs a beginning of a state transition config structure.
//****************************************************************************
void OutputTransBeg(CString StateName)
{
    CString TempCString, TempCString2;

    TempCString = StateName;
    TempCString.MakeLower();

    OutputFSMConfigFile.PutString("/* ");
    OutputFSMConfigFile.PutString(TempCString);
    OutputFSMConfigFile.PutString(" state transition configuration */");
    OutputFSMConfigFile.PutChar('\n');
    OutputFSMConfigFile.PutString("const FSM_TRANS_CONFIG_T ");
	// IF1 codegen version 34 backwards compatibility mode is selected
	if(TRUE == BackwardCompModeSelected)
	{ // THEN1 Don't limit the name size
		OutputFSMConfigFile.PutString(TempCString);
	}
	else
	{ // ELSE1 Limit the name size taking into account the "_trans_config"
		// text appended to the end
		TempCString2 = TempCString.Right(AutoGenFunctNameLimit-13);
		// The CStringFirstCharCheck call makes sure the first character
		// is not an underscore or a number
		OutputFSMConfigFile.PutString(CStringFirstCharCheck(TempCString2));
	}
	OutputFSMConfigFile.PutString("_trans_config[] =");
    OutputFSMConfigFile.PutChar('\n');
    OutputFSMConfigFile.PutChar('{');
    OutputFSMConfigFile.PutChar('\n');
}

//****************************************************************************
// Name:  OutputTrans
//
// This outputs a state transition config.
//****************************************************************************
void OutputTrans(CString TargetState, CString TransCondMask, CString TransDontCareMask,\
                 CString TransActionFunctionName)
{
    TransCondMask.MakeUpper();
    TransDontCareMask.MakeUpper();
    OutputFSMConfigFile.PutString("   { ");
    OutputFSMConfigFile.PutString(TargetState);
    OutputFSMConfigFile.PutString(", 0x");
    OutputFSMConfigFile.PutString(AddLeadingZeroes(TransCondMask));
    OutputFSMConfigFile.PutString(", 0x");
    OutputFSMConfigFile.PutString(AddLeadingZeroes(TransDontCareMask));
    OutputFSMConfigFile.PutString(", ");
	// IF1 There is a transition action
    if("" != TransActionFunctionName)
    { // THEN1 Output a pointer to the transition action function
        OutputFSMConfigFile.PutChar('&');
        OutputFSMConfigFile.PutString(TransActionFunctionName);
    }
    else
    { // ELSE1 Output a NULL pointer
        OutputFSMConfigFile.PutString("0");
    }
    OutputFSMConfigFile.PutString(" },");
    OutputFSMConfigFile.PutChar('\n');
}

//****************************************************************************
// Name:  OutputTransEnd
//
// This outputs the end of a state transition config.
//****************************************************************************
void OutputTransEnd(void)
{
    OutputFSMConfigFile.PutString("   { FSM_TRANS_END, 0, 0, 0 }");
    OutputFSMConfigFile.PutChar('\n');
    OutputFSMConfigFile.PutString("};");
    OutputFSMConfigFile.PutChar('\n');
    OutputFSMConfigFile.PutChar('\n');
}

//****************************************************************************
// Name:  AddLeadingZeroes
//
// This adds leading zeroes to a passed string integer to make it a full
// 32 bit number.
//****************************************************************************
CString AddLeadingZeroes(CString IntCString)
{
    int ii;
    CString TempCString;

    TempCString = IntCString;

	// IF1 The passed string needs to be lengthened to 8
    if(TempCString.GetLength() < 8)
    { // THEN1 Lenghen it with leading zeroes
        for(ii = (8 - IntCString.GetLength()); ii > 0; ii--)
        {
            TempCString.Insert(0, "0");
        }
    }
    return(TempCString);
}

//****************************************************************************
// Name:  OutputStateBeg
//
// This outputs the beginning of a state configuration structure.
//****************************************************************************
void OutputStateBeg(CString StateMachineName)
{
	CString TempCString;

    OutputFSMConfigFile.PutString("const FSM_STATE_CONFIG_T ");
	// IF1 codegen version 34 backwards compatibility mode is selected
	if(TRUE == BackwardCompModeSelected)
	{ // THEN1 Don't limit the name size
		OutputFSMConfigFile.PutString(StateMachineName);
	}
	else
	{ // ELSE1 Limit the name size taking into account the "_fsm_state_config"
		// text appended to the end
		TempCString = StateMachineName.Right(AutoGenFunctNameLimit-17);
		// The CStringFirstCharCheck call makes sure the first character
		// is not an underscore or a number
		OutputFSMConfigFile.PutString(CStringFirstCharCheck(TempCString));
	}
    OutputFSMConfigFile.PutString("_fsm_state_config[] =");
    OutputFSMConfigFile.PutChar('\n');
    OutputFSMConfigFile.PutString("{");
    OutputFSMConfigFile.PutChar('\n');
}

//****************************************************************************
// Name:  OutputState
//
// This outputs a state member of the state config structure.  It takes
// into account whether the state has entry, activity, and exit functions.
//****************************************************************************
void OutputState(CString StateName)
{
	CString TempCString;

    StateName.MakeLower();

	// IF11 codegen version 34 backwards compatibility mode is selected
	if(TRUE == BackwardCompModeSelected)
	{ // THEN11 Don't limit the name sizes and keep the indentation the same
		// (i.e. four spaces for a tab instead of three like everywhere else)
		OutputFSMConfigFile.PutString("    {");
		OutputFSMConfigFile.PutString(" /* ");
		OutputFSMConfigFile.PutString(StateName);
		OutputFSMConfigFile.PutString(" state configuration */");
		OutputFSMConfigFile.PutChar('\n');
		// IF1 the state has an entry action function
		if("" != Diagram.GetEntryAction(ConvertStateTextToNumber(StateName)))
		{ // THEN1 Add the function
			OutputFSMConfigFile.PutString("        &");
			OutputFSMConfigFile.PutString(StateName);
			OutputFSMConfigFile.PutString("_entry,");
		}
		else
		{ // ELSE1 Output a 0 for the function pointer
			OutputFSMConfigFile.PutString("        0,");
		}
		OutputFSMConfigFile.PutChar('\n');
		// IF2 the state has an activity function
		if("" != Diagram.GetActivityFunction(ConvertStateTextToNumber(StateName)))
		{ // THEN2 Add the function
			OutputFSMConfigFile.PutString("        &");
			OutputFSMConfigFile.PutString(StateName);
			OutputFSMConfigFile.PutString("_act,");
		}
		else
		{ // ELSE2 Output a 0 for the function pointer
			OutputFSMConfigFile.PutString("        0,");
		}
		OutputFSMConfigFile.PutChar('\n');
		// IF3 the state has an exit action function
		if("" != Diagram.GetExitAction(ConvertStateTextToNumber(StateName)))
		{ // THEN3 Add the function
			OutputFSMConfigFile.PutString("        &");
			OutputFSMConfigFile.PutString(StateName);
			OutputFSMConfigFile.PutString("_exit,");
		}
		else
		{ // ELSE3 Output a 0 for the function pointer
			OutputFSMConfigFile.PutString("        0,");
		}
		OutputFSMConfigFile.PutChar('\n');

		OutputFSMConfigFile.PutString("        &");
		OutputFSMConfigFile.PutString(StateName);
		OutputFSMConfigFile.PutString("_trans_config[0]");
		OutputFSMConfigFile.PutChar('\n');
		OutputFSMConfigFile.PutString("    },");
		OutputFSMConfigFile.PutChar('\n');
	}
	else
	{ // ELSE11 Limit the name sizes taking into account the "_entry",
		// "_act", and "_exit" text appended to the end and use three
		// spaces for tabs
		OutputFSMConfigFile.PutString("   {");
		OutputFSMConfigFile.PutString(" /* ");
		OutputFSMConfigFile.PutString(StateName);
		OutputFSMConfigFile.PutString(" state configuration */");
		OutputFSMConfigFile.PutChar('\n');
		// IF1 the state has an entry action function
		if("" != Diagram.GetEntryAction(ConvertStateTextToNumber(StateName)))
		{ // THEN1 Add the function
			OutputFSMConfigFile.PutString("      &");
			TempCString = StateName.Right(AutoGenFunctNameLimit-6);
			// The CStringFirstCharCheck call makes sure the first character
			// is not an underscore or a number
			OutputFSMConfigFile.PutString(CStringFirstCharCheck(TempCString));
			OutputFSMConfigFile.PutString("_entry,");
		}
		else
		{ // ELSE1 Output a 0 for the function pointer
			OutputFSMConfigFile.PutString("      0,");
		}
		OutputFSMConfigFile.PutChar('\n');
		// IF2 the state has an activity function
		if("" != Diagram.GetActivityFunction(ConvertStateTextToNumber(StateName)))
		{ // THEN2 Add the function
			OutputFSMConfigFile.PutString("      &");
			TempCString = StateName.Right(AutoGenFunctNameLimit-4);
			// The CStringFirstCharCheck call makes sure the first character
			// is not an underscore or a number
			OutputFSMConfigFile.PutString(CStringFirstCharCheck(TempCString));
			OutputFSMConfigFile.PutString("_act,");
		}
		else
		{ // ELSE2 Output a 0 for the function pointer
			OutputFSMConfigFile.PutString("      0,");
		}
		OutputFSMConfigFile.PutChar('\n');
		// IF3 the state has an exit action function
		if("" != Diagram.GetExitAction(ConvertStateTextToNumber(StateName)))
		{ // THEN3 Add the function
			OutputFSMConfigFile.PutString("      &");
			TempCString = StateName.Right(AutoGenFunctNameLimit-5);
			// The CStringFirstCharCheck call makes sure the first character
			// is not an underscore or a number
			OutputFSMConfigFile.PutString(CStringFirstCharCheck(TempCString));
			OutputFSMConfigFile.PutString("_exit,");
		}
		else
		{ // ELSE3 Output a 0 for the function pointer
			OutputFSMConfigFile.PutString("      0,");
		}
		OutputFSMConfigFile.PutChar('\n');

		OutputFSMConfigFile.PutString("      &");
		TempCString = StateName.Right(AutoGenFunctNameLimit-13);
		// The CStringFirstCharCheck call makes sure the first character
		// is not an underscore or a number
		OutputFSMConfigFile.PutString(CStringFirstCharCheck(TempCString));
		OutputFSMConfigFile.PutString("_trans_config[0]");
		OutputFSMConfigFile.PutChar('\n');
		OutputFSMConfigFile.PutString("   },");
		OutputFSMConfigFile.PutChar('\n');
	}
}

//****************************************************************************
// Name:  OutputStateEnd
//
// This outputs the end of a state config structure.
//****************************************************************************
void OutputStateEnd(void)
{
    OutputFSMConfigFile.PutString("};");
    OutputFSMConfigFile.PutChar('\n');
}

//****************************************************************************
// Name:  OutputMainStateMachineConfig
//
// This outputs a main state machine config structure.
//****************************************************************************
void OutputMainStateMachineConfig(void)
{
	CString TempCString;

    OutputFSMConfigFile.PutChar('\n');
    OutputFSMConfigFile.PutString("const FSM_CONFIG_T ");
    OutputFSMConfigFile.PutString(StateMachineName);
    OutputFSMConfigFile.PutString("_fsm_config =");
    OutputFSMConfigFile.PutChar('\n');
    OutputFSMConfigFile.PutString("{");
    OutputFSMConfigFile.PutChar('\n');
    OutputFSMConfigFile.PutString("   ");
    OutputFSMConfigFile.PutString(Diagram.GetInitialStateName());
    OutputFSMConfigFile.PutString(",");
    OutputFSMConfigFile.PutChar('\n');
    OutputFSMConfigFile.PutString("   &");
    OutputFSMConfigFile.PutString(StateMachineName);
    OutputFSMConfigFile.PutString("_fsm_trans_input,");
    OutputFSMConfigFile.PutChar('\n');
    OutputFSMConfigFile.PutString("   &");
	// IF11 codegen version 34 backwards compatibility mode is selected
	if(TRUE == BackwardCompModeSelected)
	{ // THEN11 Don't limit the name size
		OutputFSMConfigFile.PutString(StateMachineName);
	}
	else
	{ // ELSE11 Limit the name size taking into account the "_fsm_state_config"
		// text appended to the end
		TempCString = StateMachineName.Right(AutoGenFunctNameLimit-17);
		// The CStringFirstCharCheck call makes sure the first character
		// is not an underscore or a number
		OutputFSMConfigFile.PutString(CStringFirstCharCheck(TempCString));
	}
    OutputFSMConfigFile.PutString("_fsm_state_config[0],");
    OutputFSMConfigFile.PutChar('\n');
    OutputFSMConfigFile.PutString("   &");
    OutputFSMConfigFile.PutString(StateMachineName);
    OutputFSMConfigFile.PutString("_fsm_workspace,");
    OutputFSMConfigFile.PutChar('\n');
    OutputFSMConfigFile.PutString("   &");
    OutputFSMConfigFile.PutString(StateMachineName);
    OutputFSMConfigFile.PutString("_fsm_process_inputs,");
    OutputFSMConfigFile.PutChar('\n');
    // IF1 There is a powerup transition action
    if("" != Diagram.GetPowerupTransAction())
    { // THEN1 Add a pointer to it in the config
        OutputFSMConfigFile.PutString("   &");
		// IF2 codegen version 34 backwards compatibility mode is selected
		if(TRUE == BackwardCompModeSelected)
		{ // THEN2 Don't limit the name size
			OutputFSMConfigFile.PutString(StateMachineName);
		}
		else
		{ // ELSE2 Limit the name size taking into account the "_fsm_powerup_trans"
			// text appended to the end
			TempCString = StateMachineName.Right(AutoGenFunctNameLimit-18);
			// The CStringFirstCharCheck call makes sure the first character
			// is not an underscore or a number
			OutputFSMConfigFile.PutString(CStringFirstCharCheck(TempCString));
		}
        OutputFSMConfigFile.PutString("_fsm_powerup_trans");
    }
    else
    { // ELSE1 Add a NULL
        OutputFSMConfigFile.PutString("   0");
    }
    OutputFSMConfigFile.PutChar('\n');

    OutputFSMConfigFile.PutString("};");
    OutputFSMConfigFile.PutChar('\n');
}

//****************************************************************************
// Name:  UpdatePublicHeaderFile
//
// This updates the ..._fsm_public.h file with the #defined state name/number
// list.
//****************************************************************************
void UpdatePublicHeaderFile(void)
{
    int ii, jj, TempFileLines, State = LOOKING_FOR_BEG_AUTO_GEN_AREA;
	char TempArray[50];
    CString TempCString;

    // Open the <FSM name>_fsm_public.h file, store it in a class array, and
    // find out how many lines are in the file.
    OutputFSMPublicFile.OpenFileForReading(FSMOutputFilesPath + StateMachineName + "_fsm_public.h");
    OutputFSMPublicFile.StoreEntireFile();
    TempFileLines = OutputFSMPublicFile.GetNumberFileLines();
    OutputFSMPublicFile.CloseFile();

    // Create a new file with the same name (destroy the original file)
    OutputFSMPublicFile.OpenNewFile(FSMOutputFilesPath + StateMachineName + "_fsm_public.h");
    // FOR1 All lines in the file
    for(ii = 0; ii < TempFileLines; ii++)
    { // Process the file
        switch(State)
        {
        case(LOOKING_FOR_BEG_AUTO_GEN_AREA):
            {
                // Store all lines from the array in the new file up until
                // the /*__BEG_AUTO_GEN_AREA*/ marker
                TempCString = OutputFSMPublicFile.GetEntireFileLine(ii);
                TempCString.Remove('\n');
                if("/*__BEG_AUTO_GEN_AREA*/" == TempCString)
                {
                    State = ADDING_AUTO_GEN_DATA;
                }
                OutputFSMPublicFile.PutString(OutputFSMPublicFile.GetEntireFileLine(ii));
                break;
            }
        case(ADDING_AUTO_GEN_DATA):
            { // Add time stamp information
                OutputTimeStampAndInfo(OutputFSMPublicFile);

				// Add the config extern
				OutputFSMPublicFile.PutString("/* Config extern */\n");
				OutputFSMPublicFile.PutString("extern const FSM_CONFIG_T ");
				OutputFSMPublicFile.PutString(StateMachineName);
				OutputFSMPublicFile.PutString("_fsm_config;\n\n");

				// Add the #define state list
                OutputFSMPublicFile.PutString("/* State machine #define list of states */\n");
                for(jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
                {
                    OutputFSMPublicFile.PutString("#define ");
                    OutputFSMPublicFile.PutString(ConvertStateNumberToText(jj));
                    OutputFSMPublicFile.PutChar(' ');
                    OutputFSMPublicFile.PutString(_itoa(jj, &TempArray[0], 10));
                    OutputFSMPublicFile.PutChar('\n');
                }
                OutputFSMPublicFile.PutString("/*__END_AUTO_GEN_AREA*/");
                OutputFSMPublicFile.PutChar('\n');
                State = LOOKING_FOR_END_AUTO_GEN_AREA;
                break;
            }
        case(LOOKING_FOR_END_AUTO_GEN_AREA):
            {
                // Ignore all "old" lines up until the /*__END_AUTO_GEN_AREA*/ marker
                TempCString = OutputFSMPublicFile.GetEntireFileLine(ii);
                TempCString.Remove('\n');
				// IF1 The marker was found
                if("/*__END_AUTO_GEN_AREA*/" == TempCString)
                { // THEN1 Change states
                    State = FINISHING_UP;
                }
                break;
            }
        case(FINISHING_UP):
            {
                // Store the rest of the file after the /*__END_AUTO_GEN_AREA*/
                OutputFSMPublicFile.PutString(OutputFSMPublicFile.GetEntireFileLine(ii));
                break;
            }
        }
    }
}

//****************************************************************************
// Name:  UpdatePrivateHeaderFile
//
// This updates the ..._fsm_private.h files with all of the entry, activity,
// exit, and transition action function prototypes.
//****************************************************************************
void UpdatePrivateHeaderFile(void)
{
    int ii, jj, kk, TempFileLines, State = LOOKING_FOR_BEG_AUTO_GEN_AREA;
    CString TempCString, TempCString2, TempCString3;

    // Open the <FSM name>_fsm_public.h file, store it in a class array, and
    // find out how many lines are in the file.
    OutputFSMPrivateFile.OpenFileForReading(FSMOutputFilesPath + StateMachineName + "_fsm_private.h");
    OutputFSMPrivateFile.StoreEntireFile();
    TempFileLines = OutputFSMPrivateFile.GetNumberFileLines();
    OutputFSMPrivateFile.CloseFile();

    // Create a new file with the same name (destroy the original file)
    OutputFSMPrivateFile.OpenNewFile(FSMOutputFilesPath + StateMachineName + "_fsm_private.h");
    // FOR1 All lines in the file
    for(ii = 0; ii < TempFileLines; ii++)
    { // Process the file
        switch(State)
        {
        case(LOOKING_FOR_BEG_AUTO_GEN_AREA):
            {
                // Store all lines from the array in the new file up until
                // the /*__BEG_AUTO_GEN_AREA*/ marker
                TempCString = OutputFSMPrivateFile.GetEntireFileLine(ii);
                TempCString.Remove('\n');
                // IF1 The marker was found
                if("/*__BEG_AUTO_GEN_AREA*/" == TempCString)
                { // THEN1 Change states
                    State = ADDING_AUTO_GEN_DATA;
                }
                OutputFSMPrivateFile.PutString(OutputFSMPrivateFile.GetEntireFileLine(ii));
                break;
            }
        case(ADDING_AUTO_GEN_DATA):
            { // Add time stamp information
                OutputTimeStampAndInfo(OutputFSMPrivateFile);

                // Add transition input word extern
                OutputFSMPrivateFile.PutString("/* Transition input word extern */\n");
                OutputFSMPrivateFile.PutString("extern U32_T ");
                OutputFSMPrivateFile.PutString(StateMachineName);
                OutputFSMPrivateFile.PutString("_fsm_trans_input;\n\n");

                // Add input word processing function prototype
                OutputFSMPrivateFile.PutString("/* Input word processing function prototype */\n");
                OutputFSMPrivateFile.PutString("void ");
                OutputFSMPrivateFile.PutString(StateMachineName);
                OutputFSMPrivateFile.PutString("_fsm_process_inputs(void);\n\n");

                // Add the powerup transition action
                OutputFSMPrivateFile.PutString("/* Powerup transition action prototype */\n");
                // IF1 There is a powerup transition action
                if("" != Diagram.GetPowerupTransAction())
                { // THEN1 Add powerup transition action prototype
                    OutputFSMPrivateFile.PutString("void ");
                    // IF11 codegen version 34 backwards compatibility mode is selected
                    if(TRUE == BackwardCompModeSelected)
                    { // THEN11 Don't limit the name size
                        OutputFSMPrivateFile.PutString(StateMachineName);
                    }
                    else
                    { // ELSE11 Limit the name size taking into account the "_fsm_powerup_trans"
                        // text appended to the end
                        TempCString = StateMachineName.Right(AutoGenFunctNameLimit-18);
                        // The CStringFirstCharCheck call makes sure the first character
                        // is not an underscore or a number
                        OutputFSMPrivateFile.PutString(CStringFirstCharCheck(TempCString));
                    }
                    OutputFSMPrivateFile.PutString("_fsm_powerup_trans(void);\n");
                    if (GenerateDebugCode)
                    {
                        OutputFSMPrivateFile.PutString("#ifdef FSM_DEBUG\n");
                        OutputFSMPrivateFile.PutString("int FSM_DebugHook_");
                        OutputFSMPrivateFile.PutString(StateMachineName);
                        OutputFSMPrivateFile.PutString("_fsm_powerup_trans(void);\n");
                        OutputFSMPrivateFile.PutString("#endif /* FSM_DEBUG */\n\n");
                    }
                }

                // Add entry action prototypes
                OutputFSMPrivateFile.PutString("\n/* Entry action prototypes */\n");
                // FOR1 All states
                for(jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
                { // IF2 The current state has an entry action
                    if("" != Diagram.GetEntryAction(jj))
                    { // THEN2 Add the function prototype
                        OutputFSMPrivateFile.PutString("void ");
                        TempCString2 = ConvertStateNumberToText(jj);
                        TempCString2.MakeLower();
                        // IF22 codegen version 34 backwards compatibility mode is selected
                        if(TRUE == BackwardCompModeSelected)
                        { // THEN22 Don't limit the name size
                            OutputFSMPrivateFile.PutString(TempCString2);
                        }
                        else
                        { // ELSE22 Limit the name size taking into account the "_entry"
                            // text appended to the end
                            TempCString3 = TempCString2.Right(AutoGenFunctNameLimit-6);
                            // The CStringFirstCharCheck call makes sure the first character
                            // is not an underscore or a number
                            OutputFSMPrivateFile.PutString(CStringFirstCharCheck(TempCString3));
                        }
                        OutputFSMPrivateFile.PutString("_entry(void);");
                        OutputFSMPrivateFile.PutChar('\n');
                        if (GenerateDebugCode)
                        {
                            OutputFSMPrivateFile.PutString("#ifdef FSM_DEBUG\n");
                            OutputFSMPrivateFile.PutString("int FSM_DebugHook_");
                            OutputFSMPrivateFile.PutString(TempCString2);
                            OutputFSMPrivateFile.PutString("_entry(void);\n");
                            OutputFSMPrivateFile.PutString("#endif /* FSM_DEBUG */\n");
                        }
                    }
                } // END FOR1

                // Add activity function prototypes
                OutputFSMPrivateFile.PutString("\n/* Activity function prototypes */\n");
                // FOR2 All states
                for(jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
                { // IF3 The current state has an activity function
                    if("" != Diagram.GetActivityFunction(jj))
                    { // THEN3 Add the function prototype
                        OutputFSMPrivateFile.PutString("void ");
                        TempCString2 = ConvertStateNumberToText(jj);
                        TempCString2.MakeLower();
                        // IF33 codegen version 34 backwards compatibility mode is selected
                        if(TRUE == BackwardCompModeSelected)
                        { // THEN33 Don't limit the name size
                            OutputFSMPrivateFile.PutString(TempCString2);
                        }
                        else
                        { // ELSE33 Limit the name size taking into account the "_act"
                            // text appended to the end
                            TempCString3 = TempCString2.Right(AutoGenFunctNameLimit-4);
                            // The CStringFirstCharCheck call makes sure the first character
                            // is not an underscore or a number
                            OutputFSMPrivateFile.PutString(CStringFirstCharCheck(TempCString3));
                        }
                        OutputFSMPrivateFile.PutString("_act(void);");
                        OutputFSMPrivateFile.PutChar('\n');
                        if (GenerateDebugCode)
                        {
                            OutputFSMPrivateFile.PutString("#ifdef FSM_DEBUG\n");
                            OutputFSMPrivateFile.PutString("int FSM_DebugHook_");
                            OutputFSMPrivateFile.PutString(TempCString2);
                            OutputFSMPrivateFile.PutString("_act(void);\n");
                            OutputFSMPrivateFile.PutString("#endif /* FSM_DEBUG */\n");
                        }
                    }
                } // END FOR2

                // Add exit action prototypes
                OutputFSMPrivateFile.PutString("\n/* Exit action prototypes */\n");
                // FOR3 All states
                for(jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
                { // IF4 The current state has an exit action
                    if("" != Diagram.GetExitAction(jj))
                    { // THEN4 Add the function prototype
                        OutputFSMPrivateFile.PutString("void ");
                        TempCString2 = ConvertStateNumberToText(jj);
                        TempCString2.MakeLower();
                        // IF44 codegen version 34 backwards compatibility mode is selected
                        if(TRUE == BackwardCompModeSelected)
                        { // THEN44 Don't limit the name size
                            OutputFSMPrivateFile.PutString(TempCString2);
                        }
                        else
                        { // ELSE44 Limit the name size taking into account the "_exit"
                            // text appended to the end
                            TempCString3 = TempCString2.Right(AutoGenFunctNameLimit-5);
                            // The CStringFirstCharCheck call makes sure the first character
                            // is not an underscore or a number
                            OutputFSMPrivateFile.PutString(CStringFirstCharCheck(TempCString3));
                        }
                        OutputFSMPrivateFile.PutString("_exit(void);");
                        OutputFSMPrivateFile.PutChar('\n');
                        if (GenerateDebugCode)
                        {
                            OutputFSMPrivateFile.PutString("#ifdef FSM_DEBUG\n");
                            OutputFSMPrivateFile.PutString("int FSM_DebugHook_");
                            OutputFSMPrivateFile.PutString(TempCString2);
                            OutputFSMPrivateFile.PutString("_exit(void);\n");
                            OutputFSMPrivateFile.PutString("#endif /* FSM_DEBUG */\n");
                        }
                    }
                } // END FOR3

                // Clear the temporary string for prototype storage
                TempCString2 = "";
                // Add the transition action prototypes
                OutputFSMPrivateFile.PutString("\n/* Transition action prototypes */\n");
                // FOR4 All states
                for(jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
                {
                    // FOR5 All transitions
                    for(kk = 0; kk < Diagram.GetNumTrans(NON_SUPER_STATE, jj); kk++)
                    { // IF5 The current transition has a transition action
                        if("" != Diagram.GetTransActionFunctionName(NON_SUPER_STATE, jj, kk))
                        { // THEN5 Output the current transition action's prototype
                            TempCString = "void ";
                            TempCString += Diagram.GetTransActionFunctionName(NON_SUPER_STATE, jj, kk);
                            TempCString += "(void);";
                            TempCString += '\n';
                            if (GenerateDebugCode)
                            {
                                TempCString += "#ifdef FSM_DEBUG\n";
                                TempCString += "int FSM_DebugHook_";
                                TempCString += Diagram.GetTransActionFunctionName(NON_SUPER_STATE, jj, kk);
                                TempCString += "(void);\n";
                                TempCString += "#endif /* FSM_DEBUG */\n";
                            }
                            // IF6 The transaction function is not already there
                            if(-1 == TempCString2.Find(TempCString))
                            { // THEN6 Add it to the temporary string
                                TempCString2 += TempCString;
                            }
                        }
                    }
                }
                // Output the prototypes from the temporary string
                OutputFSMPrivateFile.PutString(TempCString2);

                OutputFSMPrivateFile.PutString("/*__END_AUTO_GEN_AREA*/");
                OutputFSMPrivateFile.PutChar('\n');
                State = LOOKING_FOR_END_AUTO_GEN_AREA;
                break;
            }
        case(LOOKING_FOR_END_AUTO_GEN_AREA):
            {
                // Ignore all "old" lines up until the /*__END_AUTO_GEN_AREA*/ marker
                TempCString = OutputFSMPrivateFile.GetEntireFileLine(ii);
                TempCString.Remove('\n');
                // IF6 The marker was found
                if("/*__END_AUTO_GEN_AREA*/" == TempCString)
                { // THEN6 Change states
                    State = FINISHING_UP;
                }
                break;
            }
        case(FINISHING_UP):
            {
                // Store the rest of the file after the /*__END_AUTO_GEN_AREA*/
                TempCString = OutputFSMPrivateFile.GetEntireFileLine(ii);
                OutputFSMPrivateFile.PutString(TempCString);
                break;
            }
        }
    }
}

//****************************************************************************
// Name:  UpdateFunctsSourceFile
//
// This updates the ..._fsm_functs.c file with all of the entry, activity,
// exit, and transition action functions.
//****************************************************************************
void UpdateFunctsSourceFile(void)
{
    int ii, jj, kk, TempFileLines, State = LOOKING_FOR_BEG_AUTO_GEN_AREA;
    CString TempCString, TempCString2, TempCString3, TempCString4, TempCString5;
    CString TempStateName, TempSuperStateName;

    // Open the <FSM name>_fsm_public.h file, store it in a class array, and
    // find out how many lines are in the file.
    OutputFSMFunctsFile.OpenFileForReading(FSMOutputFilesPath + StateMachineName + "_fsm_functs.c");
    OutputFSMFunctsFile.StoreEntireFile();
    TempFileLines = OutputFSMFunctsFile.GetNumberFileLines();
    OutputFSMFunctsFile.CloseFile();

    // Create a new file with the same name (destroy the original file)
    OutputFSMFunctsFile.OpenNewFile(FSMOutputFilesPath + StateMachineName + "_fsm_functs.c");
    // FOR1 All lines in the file
    for(ii = 0; ii < TempFileLines; ii++)
    { // Process the file
        switch(State)
        {
        case(LOOKING_FOR_BEG_AUTO_GEN_AREA):
            {
                // Store all lines from the array in the new file up until
                // the /*__BEG_AUTO_GEN_AREA*/ marker
                TempCString = OutputFSMFunctsFile.GetEntireFileLine(ii);
                TempCString.Remove('\n');
                // IF1 The marker was found
                if("/*__BEG_AUTO_GEN_AREA*/" == TempCString)
                { // THEN1 Change states
                    State = ADDING_AUTO_GEN_DATA;
                }
                OutputFSMFunctsFile.PutString(OutputFSMFunctsFile.GetEntireFileLine(ii));
                break;
            }
        case(ADDING_AUTO_GEN_DATA):
            {
                OutputTimeStampAndInfo(OutputFSMFunctsFile);

                // Add the powerup transition action
                OutputFSMFunctsFile.PutString("/* Powerup transition action definition */\n");
                // IF2 There is a powerup transition action function
                if("" != Diagram.GetPowerupTransAction())
                { // THEN2 Add powerup transition action prototype
                    OutputFSMFunctsFile.PutString("void ");
                    // IF22 codegen version 34 backwards compatibility mode is selected
                    if(TRUE == BackwardCompModeSelected)
                    { // THEN22 Don't limit the name size
                        OutputFSMFunctsFile.PutString(StateMachineName);
                    }
                    else
                    { // ELSE22 Limit the name size taking into account the "_fsm_powerup_trans"
                        // text appended to the end
                        TempCString5 = StateMachineName.Right(AutoGenFunctNameLimit-18);
                        // The CStringFirstCharCheck call makes sure the first character
                        // is not an underscore or a number
                        OutputFSMFunctsFile.PutString(CStringFirstCharCheck(TempCString5));
                    }
                    OutputFSMFunctsFile.PutString("_fsm_powerup_trans(void)\n");
                    OutputFSMFunctsFile.PutString("{\n");
                    if (GenerateDebugCode)
                    {
                        OutputFSMFunctsFile.PutString("#ifdef FSM_DEBUG\n");
                        OutputFSMFunctsFile.PutString("   FSM_DebugHook_");
                        OutputFSMFunctsFile.PutString(StateMachineName);
                        OutputFSMFunctsFile.PutString("_fsm_powerup_trans();\n");
                        OutputFSMFunctsFile.PutString("#endif /* FSM_DEBUG */\n");
                    }
                    OutputFSMFunctsFile.PutString(Diagram.GetPowerupTransAction());
                    OutputFSMFunctsFile.PutString("}\n\n");
                }
#if 0
                else
                {
                    if (GenerateDebugCode)
                    {
                        OutputFSMFunctsFile.PutString("#ifdef FSM_DEBUG\n");
                        OutputFSMFunctsFile.PutString("void ");
                        OutputFSMFunctsFile.PutString(StateMachineName);
                        OutputFSMFunctsFile.PutString("_fsm_powerup_trans(void)\n");
                        OutputFSMFunctsFile.PutString("{\n");
                        OutputFSMFunctsFile.PutString("   FSM_DebugHook_");
                        OutputFSMFunctsFile.PutString(StateMachineName);
                        OutputFSMFunctsFile.PutString("_fsm_powerup_trans();\n");
                        OutputFSMFunctsFile.PutString("}\n");
                        OutputFSMFunctsFile.PutString("#endif /* FSM_DEBUG */\n\n");
                    }
                }
#endif
                // Add the entry actions
                OutputFSMFunctsFile.PutString("\n/* Entry action function definitions */\n");
                for(jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
                {
                    // IF3 There is an entry action function
                    if("" != Diagram.GetEntryAction(jj))
                    { // THEN3 Add the function
                        TempCString = ConvertStateNumberToText(jj);
                        // IF333 codegen version 34 backwards compatibility mode is not selected
                        if(FALSE == BackwardCompModeSelected)
                        { // THEN333 Output a function comment first
                            TempCString4 = "/* ";
                            TempCString4 += TempCString;
                            TempCString4 += " entry action function definition */";
                            TempCString4 += '\n';
                            OutputFSMFunctsFile.PutString(TempCString4);
                        }
                        OutputFSMFunctsFile.PutString("void ");
                        TempCString.MakeLower();
                        // IF33 codegen version 34 backwards compatibility mode is selected
                        if(TRUE == BackwardCompModeSelected)
                        { // THEN33 Don't limit the name size
                            OutputFSMFunctsFile.PutString(TempCString);
                        }
                        else
                        { // ELSE33 Limit the name size taking into account the "_entry"
                            // text appended to the end
                            TempCString5 = TempCString.Right(AutoGenFunctNameLimit-6);
                            // The CStringFirstCharCheck call makes sure the first character
                            // is not an underscore or a number
                            OutputFSMFunctsFile.PutString(CStringFirstCharCheck(TempCString5));
                        }
                        OutputFSMFunctsFile.PutString("_entry(void)\n{\n");
                        if (GenerateDebugCode)
                        {
                            OutputFSMFunctsFile.PutString("#ifdef FSM_DEBUG\n");
                            OutputFSMFunctsFile.PutString("   FSM_DebugHook_");
                            OutputFSMFunctsFile.PutString(TempCString);
                            OutputFSMFunctsFile.PutString("_entry();\n");
                            OutputFSMFunctsFile.PutString("#endif /* FSM_DEBUG */\n");
                        }
                        OutputFSMFunctsFile.PutString(Diagram.GetEntryAction(jj));
                        OutputFSMFunctsFile.PutString("}\n\n");
                    }
                }

                // Add the activity functions
                OutputFSMFunctsFile.PutString("\n/* Activity function definitions */\n");
                for(jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
                {
                    // IF4 There is an activity function
                    if("" != Diagram.GetActivityFunction(jj))
                    { // THEN4 Add the function
                        TempCString = ConvertStateNumberToText(jj);
                        // IF444 codegen version 34 backwards compatibility mode is not selected
                        if(FALSE == BackwardCompModeSelected)
                        { // THEN444 Output a function comment first
                            TempCString4 = "/* ";
                            TempCString4 += TempCString;
                            TempCString4 += " activity function definition */";
                            TempCString4 += '\n';
                            OutputFSMFunctsFile.PutString(TempCString4);
                        }
                        OutputFSMFunctsFile.PutString("void ");
                        TempCString.MakeLower();
                        // IF44 codegen version 34 backwards compatibility mode is selected
                        if(TRUE == BackwardCompModeSelected)
                        { // THEN44 Don't limit the name size
                            OutputFSMFunctsFile.PutString(TempCString);
                        }
                        else
                        { // ELSE44 Limit the name size taking into account the "_act"
                            // text appended to the end
                            TempCString5 = TempCString.Right(AutoGenFunctNameLimit-4);
                            // The CStringFirstCharCheck call makes sure the first character
                            // is not an underscore or a number
                            OutputFSMFunctsFile.PutString(CStringFirstCharCheck(TempCString5));
                        }
                        OutputFSMFunctsFile.PutString("_act(void)");
                        OutputFSMFunctsFile.PutChar('\n');
                        OutputFSMFunctsFile.PutChar('{');
                        OutputFSMFunctsFile.PutChar('\n');
                        if (GenerateDebugCode)
                        {
                            OutputFSMFunctsFile.PutString("#ifdef FSM_DEBUG\n");
                            OutputFSMFunctsFile.PutString("   FSM_DebugHook_");
                            OutputFSMFunctsFile.PutString(TempCString);
                            OutputFSMFunctsFile.PutString("_act();\n");
                            OutputFSMFunctsFile.PutString("#endif /* FSM_DEBUG */\n");
                        }
                        OutputFSMFunctsFile.PutString(Diagram.GetActivityFunction(jj));
                        OutputFSMFunctsFile.PutChar('}');
                        OutputFSMFunctsFile.PutChar('\n');
                        OutputFSMFunctsFile.PutChar('\n');
                    }
                }

                // Add the exit actions
                OutputFSMFunctsFile.PutString("\n/* Exit action function definitions */\n");
                for(jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
                {
                    // IF5 There is an exit action function
                    if("" != Diagram.GetExitAction(jj))
                    { // THEN5 Add the function
                        TempCString = ConvertStateNumberToText(jj);
                        // IF555 codegen version 34 backwards compatibility mode is not selected
                        if(FALSE == BackwardCompModeSelected)
                        { // THEN555 Output a function comment first
                            TempCString4 = "/* ";
                            TempCString4 += TempCString;
                            TempCString4 += " exit action function definition */";
                            TempCString4 += '\n';
                            OutputFSMFunctsFile.PutString(TempCString4);
                        }
                        OutputFSMFunctsFile.PutString("void ");
                        TempCString.MakeLower();
                        // IF55 codegen version 34 backwards compatibility mode is selected
                        if(TRUE == BackwardCompModeSelected)
                        { // THEN55 Don't limit the name size
                            OutputFSMFunctsFile.PutString(TempCString);
                        }
                        else
                        { // ELSE55 Limit the name size taking into account the "_exit"
                            // text appended to the end
                            TempCString5 = TempCString.Right(AutoGenFunctNameLimit-5);
                            // The CStringFirstCharCheck call makes sure the first character
                            // is not an underscore or a number
                            OutputFSMFunctsFile.PutString(CStringFirstCharCheck(TempCString5));
                        }
                        OutputFSMFunctsFile.PutString("_exit(void)");
                        OutputFSMFunctsFile.PutChar('\n');
                        OutputFSMFunctsFile.PutChar('{');
                        OutputFSMFunctsFile.PutChar('\n');
                        if (GenerateDebugCode)
                        {
                            OutputFSMFunctsFile.PutString("#ifdef FSM_DEBUG\n");
                            OutputFSMFunctsFile.PutString("   FSM_DebugHook_");
                            OutputFSMFunctsFile.PutString(TempCString);
                            OutputFSMFunctsFile.PutString("_exit();\n");
                            OutputFSMFunctsFile.PutString("#endif /* FSM_DEBUG */\n");
                        }
                        OutputFSMFunctsFile.PutString(Diagram.GetExitAction(jj));
                        OutputFSMFunctsFile.PutChar('}');
                        OutputFSMFunctsFile.PutChar('\n');
                        OutputFSMFunctsFile.PutChar('\n');
                    }
                }

                // Clear the temporary string for transition action storage
                TempCString2 = "";
                // Add the transition actions
                OutputFSMFunctsFile.PutString("\n/* Transition action function definitions */\n");
                // FOR4 All states
                for(jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
                { // Put a state comment for the transition actions */
                    TempStateName = Diagram.GetStateName(NON_SUPER_STATE, jj);
                    TempCString4 = "/* ";
                    TempCString4 += TempStateName;
                    TempCString4 += " state transition action function definitions */";
                    TempCString4 += '\n';
                    // FOR5 All transitions
                    for(kk = 0; kk < Diagram.GetNumTrans(NON_SUPER_STATE, jj); kk++)
                    { // IF5 The current transition has a transition action
                        if("" != Diagram.GetTransActionFunctionName(NON_SUPER_STATE, jj, kk))
                        { // THEN5 Check to see if this is a super state transition action
                            TempSuperStateName = Diagram.GetTransAddedBySuperState(jj, kk);
                            // IF6 This is a super state transition action
                            if("" != TempSuperStateName)
                            { // THEN6 put a super state comment in for the trans action
                                TempStateName = TempSuperStateName;
                                TempCString4 = "/* ";
                                TempCString4 += TempStateName;
                                TempCString4 += " super state transition action function definitions */";
                                TempCString4 += '\n';
                            }
                            // IF7 The state comment is not already there
                            if(-1 == TempCString2.Find(TempCString4))
                            { // THEN7 Add it
                                TempCString2 += TempCString4;
                            }
                            // Output a transition action comment
                            TempCString3 = "/* ";
                            TempCString3 += TempStateName;
                            TempCString3 += " to ";
                            TempCString3 += ConvertStateNumberToText(Diagram.GetTransTargetState(NON_SUPER_STATE, jj, kk));
                            TempCString3 += " transition action */";
                            TempCString3 += '\n';
                            // Output the current transition action's prototype
                            TempCString = "void ";
                            TempCString += Diagram.GetTransActionFunctionName(NON_SUPER_STATE, jj, kk);
                            TempCString += "(void)";
                            TempCString += '\n';
                            TempCString += '{';
                            TempCString += '\n';
                            if (GenerateDebugCode)
                            {
                                TempCString += "#ifdef FSM_DEBUG\n";
                                TempCString += "   FSM_DebugHook_";
                                TempCString += Diagram.GetTransActionFunctionName(NON_SUPER_STATE, jj, kk);
                                TempCString += "();\n";
                                TempCString += "#endif /* FSM_DEBUG */\n";
                            }
                            TempCString += Diagram.GetTransActionFunctionBody(NON_SUPER_STATE, jj, kk);
                            TempCString += '}';
                            TempCString += '\n';
                            TempCString += '\n';

                            // IF8 The transaction function body is not already there
                            if(-1 == TempCString2.Find(TempCString))
                            { // THEN8 Add it to the temporary string
                                TempCString2 += TempCString3;
                                TempCString2 += TempCString;
                            }
                        }
                    }
                }

                // Output the transition actions from the temporary string
                OutputFSMFunctsFile.PutString(TempCString2);

                OutputFSMFunctsFile.PutString("/*__END_AUTO_GEN_AREA*/");
                OutputFSMFunctsFile.PutChar('\n');
                State = LOOKING_FOR_END_AUTO_GEN_AREA;
                break;
            }
        case(LOOKING_FOR_END_AUTO_GEN_AREA):
            {
                // Ignore all "old" lines up until the /*__END_AUTO_GEN_AREA*/ marker
                TempCString = OutputFSMFunctsFile.GetEntireFileLine(ii);
                TempCString.Remove('\n');
                // IF6 The marker is found
                if("/*__END_AUTO_GEN_AREA*/" == TempCString)
                { // THEN6 Change states
                    State = FINISHING_UP;
                }
                break;
            }
        case(FINISHING_UP):
            {
                // Store the rest of the file after the /*__END_AUTO_GEN_AREA*/
                OutputFSMFunctsFile.PutString(OutputFSMFunctsFile.GetEntireFileLine(ii));
                break;
            }
        }
    }
}


//****************************************************************************
// Name:  UpdateDebugSourceFile
//
// This generates the ..._fsm_debug.txt file with all of the entry, activity,
// exit, and transition action debug hook functions (stubs).
//****************************************************************************
void UpdateDebugSourceFile(void)
{
    File outFile;
    CString TempCString;

    // Create a new file with the same name (destroy the original file)
    outFile.OpenNewFile(FSMOutputFilesPath + StateMachineName + "_fsm_debug.txt");
    OutputTimeStampAndInfo(outFile);

    // Add the powerup transition action
    if("" != Diagram.GetPowerupTransAction())
    {
        outFile.PutString("\n");
        outFile.PutString("\n");
        outFile.PutString("/*\n");
        outFile.PutString(" * FSB Debug Hook Function for Powerup transition action.\n");
        outFile.PutString(" */\n");
        outFile.PutString("int FSM_DebugHook_");
        outFile.PutString(StateMachineName);
        outFile.PutString("_fsm_powerup_trans(void)\n");
        outFile.PutString("{\n");
        outFile.PutString("   // fprintf(stdout, \"");
        outFile.PutString(StateMachineName);
        outFile.PutString("_fsm_powerup_trans()\\n\");\n");
        outFile.PutString("   // fflush(stdout);\n");
        outFile.PutString("   return 0;\n");
        outFile.PutString("}\n");
    }

    // Add the entry actions
    for(int jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
    {
        if("" != Diagram.GetEntryAction(jj))
        {
            TempCString = ConvertStateNumberToText(jj);
            TempCString.MakeLower();
            outFile.PutString("\n");
            outFile.PutString("\n");
            outFile.PutString("/*\n");
            outFile.PutString(" * FSB Debug Hook Function for ");
            outFile.PutString(TempCString);
            outFile.PutString("_entry().\n");
            outFile.PutString(" */\n");
            outFile.PutString("int FSM_DebugHook_");
            outFile.PutString(TempCString);
            outFile.PutString("_entry(void)\n");
            outFile.PutString("{\n");
            outFile.PutString("   // fprintf(stdout, \"");
            outFile.PutString(TempCString);
            outFile.PutString("_entry()\\n\");\n");
            outFile.PutString("   // fflush(stdout);\n");
            outFile.PutString("   return 0;\n");
            outFile.PutString("}\n");
        }
    }

    // Add the activity functions
    for(int jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
    {
        if("" != Diagram.GetActivityFunction(jj))
        {
            TempCString = ConvertStateNumberToText(jj);
            TempCString.MakeLower();
            outFile.PutString("\n");
            outFile.PutString("\n");
            outFile.PutString("/*\n");
            outFile.PutString(" * FSB Debug Hook Function for ");
            outFile.PutString(TempCString);
            outFile.PutString("_act().\n");
            outFile.PutString(" */\n");
            outFile.PutString("int FSM_DebugHook_");
            outFile.PutString(TempCString);
            outFile.PutString("_act(void)\n");
            outFile.PutString("{\n");
            outFile.PutString("   // fprintf(stdout, \"");
            outFile.PutString(TempCString);
            outFile.PutString("_act()\\n\");\n");
            outFile.PutString("   // fflush(stdout);\n");
            outFile.PutString("   return 0;\n");
            outFile.PutString("}\n");
        }
    }

    // Add the exit actions.
    for(int jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
    {
        if("" != Diagram.GetExitAction(jj))
        {
            TempCString = ConvertStateNumberToText(jj);
            TempCString.MakeLower();
            outFile.PutString("\n");
            outFile.PutString("\n");
            outFile.PutString("/*\n");
            outFile.PutString(" * FSB Debug Hook Function for ");
            outFile.PutString(TempCString);
            outFile.PutString("_exit().\n");
            outFile.PutString(" */\n");
            outFile.PutString("int FSM_DebugHook_");
            outFile.PutString(TempCString);
            outFile.PutString("_exit(void)\n");
            outFile.PutString("{\n");
            outFile.PutString("   // fprintf(stdout, \"");
            outFile.PutString(TempCString);
            outFile.PutString("_exit()\\n\");\n");
            outFile.PutString("   // fflush(stdout);\n");
            outFile.PutString("   return 0;\n");
            outFile.PutString("}\n");
        }
    }

    // Add the transition actions.
    CString stringBuffer;
    for(int jj = 0; jj < Diagram.GetNumStates(NON_SUPER_STATE); jj++)
    {
        CString stateName = Diagram.GetStateName(NON_SUPER_STATE, jj);
        for(int kk = 0; kk < Diagram.GetNumTrans(NON_SUPER_STATE, jj); kk++)
        {
            if("" != Diagram.GetTransActionFunctionName(NON_SUPER_STATE, jj, kk))
            {
                CString superStateName = Diagram.GetTransAddedBySuperState(jj, kk);
                if("" != superStateName)
                {
                    stateName = superStateName;
                }

                // Output a transition action comment
                CString functionName = Diagram.GetTransActionFunctionName(NON_SUPER_STATE, jj, kk);
                CString commentText = "\n\n";
                commentText += "/*\n";
                commentText += " * FSB Debug Hook Function for ";
                commentText += functionName;
                commentText += "().\n";
                commentText += " *\n";
                commentText += " *   ";
                commentText += stateName;
                commentText += " to ";
                commentText += ConvertStateNumberToText(Diagram.GetTransTargetState(NON_SUPER_STATE, jj, kk));
                commentText += " transition action.\n";
                commentText += " */\n";

                // Output the current transition action's prototype
                CString functionText = "int FSM_DebugHook_";
                functionText += functionName;
                functionText += "(void)\n";
                functionText += "{\n";
                functionText += "   // fprintf(stdout, \"";
                functionText += functionName;
                functionText += "()\\n\");\n";
                functionText += "   // fflush(stdout);\n";
                functionText += "   return 0;\n";
                functionText += "}\n";

                if(-1 == stringBuffer.Find(functionText))
                {
                    stringBuffer += commentText;
                    stringBuffer += functionText;
                }
            }
        }
    }
    outFile.PutString(stringBuffer);

    outFile.CloseFile();
}
